library(readr)
library(dplyr)

### define a function to process and filter the subassembly
# subassembly:  character or connection; file with subassembly data (generated by script `subassembly/subassembly.sh`) 
# controls:     character or connection; file with barcodes for control constructs with the corresponding 5' UTR (in `data/subassembly`)
# annotation:   character or connection; file with promoter sequences and additional annotations
#               (for genomic promoter libraries generated by script `promoter_annotation/extract_promoter_seqs.sh`)
filter_subassembly <- function(subassembly, controls, annotation) {
  # load subassembly
  subassembly <- read_tsv(subassembly)
  
  # load control barcodes
  controls <- read_tsv(controls) %>%
    mutate(
      promoter = recode(promoter, 'none' = 'noPRO', '35S' = 'withPRO'),
      enhancer = recode(enhancer, 'none' = 'noENH', '35S' = 'withENH'),
      variant = paste('control', promoter, enhancer, sep = '-')
    ) %>%
    select(barcode, variant)
  
  # add annotation and controls to subassembly
    subassembly <- inner_join(
      subassembly,
      read_tsv(annotation),
      by = 'gene'
    ) %>%
    bind_rows(
      controls
    )
  
  # barcodes linked to a single promoter
  subassembly.okay <- subassembly %>%
    group_by(barcode) %>%
    filter(n() == 1) %>%
    ungroup() %>%
    select(-assembly.count)
  
  # barcodes with more than one associated fragment
  subassembly.to.fix <- subassembly %>%
    filter(! barcode %in% subassembly.okay$barcode)
  
  # combine barcodes with multiple variants of the same promoter (use most common variant if it is at least 10 times more common than the second most common one)
  subassembly.to.fix <- subassembly.to.fix %>%
    group_by(across(c(-variant, -start, -stop, -assembly.count))) %>%
    arrange(desc(assembly.count)) %>%
    summarise(
      variant = case_when(
        n_distinct(variant) == 1 ~ first(variant),
        first(assembly.count) >= 10 * nth(assembly.count, 2) ~ first(variant),
        TRUE ~ paste('multiple (', paste(variant, collapse = '/'), ')', sep = '')
      ),
      start = case_when(
        n_distinct(start) == 1 ~ first(start),
        first(assembly.count) >= 10 * nth(assembly.count, 2) ~ first(start),
        TRUE ~ NA_real_
      ),
      stop = case_when(
        n_distinct(stop) == 1 ~ first(stop),
        first(assembly.count) >= 10 * nth(assembly.count, 2) ~ first(stop),
        TRUE ~ NA_real_
      ),
      most.common.count = first(assembly.count),
      assembly.count = paste(assembly.count, collapse = '/')
    ) %>%
    ungroup()
  
  # combine barcodes with multiple promoters (use most common promoter if it is at least 20 times more common than the second most common one)
  subassembly.to.fix <- subassembly.to.fix %>%
    group_by(barcode) %>%
    arrange(desc(most.common.count)) %>%
    summarise(
      gene = case_when(
        n() == 1 ~ first(gene),
        first(most.common.count) >= 20 * nth(most.common.count, 2) ~ first(gene),
        TRUE ~ paste('multiple (', paste(gene, collapse = '/'), ')', sep = '')
      ),
      across(c(-gene, -ends_with('count')), function(x) ifelse(grepl('multiple', gene), NA, first(x)))
    ) %>%
    ungroup()
  
  # combine subassembly.okay and subassembly.to.fix
  subassembly <- bind_rows(
    subassembly.okay,
    subassembly.to.fix
  )
  
  # filter out barcodes linked to multiple promoters
  subassembly <- subassembly %>%
    filter(! grepl('multiple', gene, fixed = TRUE) & ! grepl('multiple', variant, fixed = TRUE))
  
  # annotate full-length promoters and calculate GC content
  subassembly <- subassembly %>%
    mutate(
      FL = if_else(is.na(start) | is.na(stop), FALSE, start == 1 & stop == if_else(gene == '35Spr', 51, 170)),
      GC = nchar(gsub('A|T', '', sequence)) / nchar(sequence)
    ) %>%
    select(-sequence)
  
  return(subassembly)
}


### subassemblies for genomic promoter libraries
subassembly.At <- filter_subassembly(
  subassembly = '../data/subassembly/subassembly_pPSup_AtPRO_ZmUTR_variant.tsv.gz',
  controls = '../data/subassembly/controls_ZmUTR.tsv',
  annotation = '../data/promoter_annotation/Arabidopsis_all_promoters_unique.tsv')

subassembly.Zm <- filter_subassembly(
  subassembly = '../data/subassembly/subassembly_pPSup_plPRO_variant.tsv.gz',
  controls = '../data/subassembly/controls_ZmUTR.tsv',
  annotation = '../data/promoter_annotation/Maize_all_promoters_unique.tsv')

subassembly.Sb <- filter_subassembly(
  subassembly = '../data/subassembly/subassembly_pPSup_plPRO_variant.tsv.gz',
  controls = '../data/subassembly/controls_SbUTR.tsv',
  annotation = '../data/promoter_annotation/Sorghum_all_promoters_unique.tsv')

## the subassembly columns are:
# barcode:      barcode in library
# gene:         name of the gene(s) associated with this promoter sequence
# start & stop: start & stop coordinates of the promoter in respect to the array sequence. Full length sequences starts at 1 and end at 170 (51 for 35Spr).
#               start = 1 corresponds to base -165 in respect to the annotated TSS; stop = 170 corresponds to base +5 in respect to the annotated TSS
# FL:           whether the promoter is truncated (FALSE) or full-length (TRUE)
# variant:      WT if sequence is identical to array-synthesized one or specification of mutations of this sequence
# type:         type of associated gene ('protein_coding' or 'miRNA')
# strand:       orientation of associated gene
# UTR:          whether the gene contains an annotated 5' UTR (i.e. the TSS is distinct from the start of the coding sequence)
# mutations:    mutations introduced in the array-synthesized sequences to remove restriction enzyme sites
# GC:           GC content of the sequence


### save to files
write_tsv(subassembly.At, 'subassembly/subassembly_At.tsv')
write_tsv(subassembly.Zm, 'subassembly/subassembly_Zm.tsv')
write_tsv(subassembly.Sb, 'subassembly/subassembly_Sb.tsv')


### subassemblies for validation libraries
subassembly.val.one <- filter_subassembly(
  subassembly = '../data/subassembly/subassembly_pPSup_valPRO_variant.tsv.gz',
  controls  = '../data/subassembly/controls_ZmUTR.tsv',
  annotation = 'validation_sequences/validation_seqs.tsv')

subassembly.val.two <- filter_subassembly(
  subassembly = '../data/subassembly/subassembly_pPSup_valPRO_variant.tsv.gz',
  controls  = '../data/subassembly/controls_ZmUTR.tsv',
  annotation = 'validation_sequences/validation_seqs_evo.tsv')

## the subassembly columns are:
# barcode:      barcode in library
# gene:         name of the validation construct
# start & stop: start & stop coordinates of the cloned sequence in respect to the array sequence. Full length sequences starts at 1 and end at 170
# FL:           whether the promoter is truncated (FALSE) or full-length (TRUE)
# variant:      WT if sequence is identical to array-synthesized one or specification of mutations of this sequence
# GC:           GC content of the sequence
# sp:           species from which the construct is derived


### save to files
write_tsv(subassembly.val.one, 'subassembly/subassembly_PROval.tsv')
write_tsv(subassembly.val.two, 'subassembly/subassembly_PROevo.tsv')